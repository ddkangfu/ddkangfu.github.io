---
layout: default
title: Git Reset
category: 开发
comments: true
---

# Git Rest


git rest 命令的两个主要用法：

```
git reset [-q] [<commit>] [--] <paths> ...
git reset [--soft|--mixed|--hard|--merge|--keep] [-q] [<commit>]
```

可选项<ocmmit>如果未提供（引用或提交ID），则默认使用HEAD。

第一种用法：是用指定提交<commit>下的文件来替换暂存区中的文件。如`git reset HEAD <paths>`相当于取消之前`git add <paths>`命令时改变的暂存区。

第二种用法：用来对工作区或暂存区进行重置。

1. 使用--hard参数：

* 替换引用的指向；

* 替换暂存区；

* 替换工作区。

2. 使用--soft参数：

* 替换引用的指向。

3. 使用--mixed参数：

* 更改引用的指向；

* 替换暂存区；

### git reset --soft的使用例子

在使用git进行协作开发时，我们经常需要将自己的修改生成patch发给被人，但是在修改代码的过程中我们进行了很多次的提交，如何生成从最初的代码状态到最终代码状态的patch呢？下面要介绍的功能是应对这中情况。

现假设我们git软件仓库中的分支情况如下：

a-->b-->c

也就是说我们的代码从状态a修改到状态b，进行一次提交，然后再修改到状态c，进行一次提交。这时我们已经肯定由a到c的修改是正确的，不再需要状态b了，并且要把从a到c的变化生成一个patch发送给别人。如果直接打包的话会生成两个path，那么如何生成一个patch呢，这时就需要git-reset命令。

首先给状态a创建一个tag，假设名称为A，然后执行

```
git-reset --soft A
```

这样我们的软件仓库就变为

a

状态b和状态c都已经被删除了，但是当前的代码并没有被改变，还是状态c的代码，这时我们做一次提交，软件仓库变成下面的样子：

a-->d

状态d和状态c所对应的代码是完全相同的，只是名字不同。现在就可以生成一个patch打包发给别人了。
